# CarCar

Team:

* Hanna Erickson - service microservice
* Ryan Holzer - sales microservice

## Design

## Service microservice

To begin the project, my partner and I did some brainstorming. We discussed the larger scope of the project and decided that I would handle the service portion while Ryan would handle the sales. To begin, I created my models. In the initial planning of the project, I had discovered the need for an Automobile Value Object, as well as a Technician Model and an Appointment Model. The only data I would need to track automobiles from the inventory would be their VIN, so that is the only field necessary on my AutomobileVO model. To create a technician I created a field for a name and employee number. For simplicity's sake, my employee number is a small positive integer. It is possible that this will match the ID of the employee generated on creation, but all changes to do with employees are made through the employee number. Finally, the appointment model takes a few fields: vin number, owner of the vehicle, the date and time of the appointment, the reason, the technician taking the appointment, and the status of the appointment as well as the owner. The vin number is just a CharField. I did not want any ForeignKey relationship here to an AutomobileVO as anyone may create a service appointment, so I needed to be able to accept all vin numbers and not those of just autos in the inventory. I chose to separate the date and time field after making some adjustments to the Model Encoder, as this simplified the formatting necessary to display my data in tables. The technician field is a ForeignKey to my technician instances. On delete I chose CASCASE, as if a technician is fired or unavailable for that service appointment, the appointment would likely be cancelled until it can be rescheduled with someone else. I did not want appointments to exist without a technician there to fulfill it. Finally, I created a field to track the VIP status of an owner, that is if they purchased a vehicle from the dealer or not. My poller was created via an API call to the inventory service to fetch all automobiles as they were generated either in Insomnia or our completed form. VO instances were created from this.

There are two major groupings for the views I created: views dealing with creating or modifying technicians, and views dealing with creating or modifying appointments. Full CRUD functionality was implemented for both models. The structure of the views will be fairly similar: a GET request to view all instances, a POST to create an instance using data from a form that matches my models, another GET request passed with an ID to view an instance, a PUT request to update information, and finally a DELETE. Error messages were handled in Try/Except statements when necessary, typically when fetching an instance object of a technician or appointment. A separate file stores the encoders created for these views.

Several React components needed to be created for the Service portion of the project. My partner and I decided the flexibility of functional components would better serve us in this project. I began by creating a form to create a new technician. A basic form template was rendered, and my onSubmit handler created the new technician instance by posting the request to the correct API url. The same basic strategy was followed to create an appointment. First, however, a technician had to be fetched in my useEffect method to populate a drop-down. This data was mapped through to populate the drop-down and all other fields are simple inputs. In the appointment list, a simple table was created to display my data fetched from the API. Functionality was created to delete an appointment as well as mark the appointment as completed. This was key, as later I would need to implement an appointment history view, so there needed to be a distinct difference between cancelled/deleted appointments and finished ones. A simple filter was applied when mapping through my appointment data to only list appointments that did not have the status of "COMPLETE". Finally, for the appointment history view, the table is nearly identical to the one for listing all appointments save for the fact that there is no need for the buttons to cancel or finish an appointment. This view needed to filter data by VIN number, which was done by creating a variable to hold a "query". I used the Bootstrap "search" input with an onChange handler to set my query as whatever was typed into the search bar. Finally my list of appointments was filtered, only showing those that included that query (or parts of that query).

For the shared inventory service, I handled most of the list views for automobiles, models, and manufacturers. After my partner had created the form components, we decided to import the form components into their corresponding list components for a more fluid design. Creation of a new manufacturer, model, or automobile now hot refreshes to display the new instance on the same page as soon as the form is submitted. I handled updating the Nav bar by using a Bootstrap template slightly different from the one initially provided to us. This allowed us to use drop-down menus in the Nav to organize our links. Some minor styling changes were made to ensure uniformity and ubiquitous language throughout the site. Finally, a Bootstrap carousel was added to the home page to add some additional styling, body, and realism to our site, belovedly christened "Dorsey's Dealers".


## Sales microservice

In building the sales microservice for project beta, I started with the models. I first created the sales person and customer models as they were the most straightforward. For the sale model, used both the customer and the sales person as foreign keys, deciding to protect the sale upon deletion of a customer or sales person. My thinking here was, in a real world application, you would most likely want to keep track of your sale whether or not your customer or sales person stuck around.  Finally, created an automobile value object, with only a vin number attribute, as it was all I would need to track sales. This led to creating poller (and a superuser to easily check that said poller was working, which involved registering my models in the admin.py file) to make an internal api call to the inventory micro service, pulling all automobiles as they were created, and making value objects with the vin number of each instance of an automobile object.

Next, I would focus on my API calls. I, using full CRUD, created list and detail views for each model, allowing me to view all instances of a given model class, create an instance, or show the details of/edit/delete an instance of a model class using the id for reference in its path. Each view was registered in a newly created urls.py file in my sales_rest folder. After each view was created and each path was registered, my models were all given their own encoders for list/detail API calls, which were placed in their own, encoders.py file.

Then, it was time for the front end. In spite being new to React, my diligent partner and I opted to work with classless components, using hooks. I first created all forms, making “POST” API calls within arrow function event handlers to create new instances of models in my database. Once the more basic forms were functional, I moved onto the sales records. For the component that creates a sale, I had to make API calls in order to retrieve all instances of vehicles in inventory, all sales persons, and all customers in my database to create dropdowns for each respective category. These calls were placed inside of a single useEffect to fetch the data upon initial render of the component, using an empty list as its dependency.  I then added a price, sent a “POST” API call to create the sale, and another to remove the vehicle from inventory. To then list the sales, I needed to use a filter function in order to show all sales, but also show sales organized by each individual sales person.

Finally, my partner and I collaborated on the inventory microservice. I created the forms, and she created the list pages, following the aforementioned formula. Then, while she began working on some style upgrades, I focused on making each form component a child of the list component. In order make the list re-render upon creation of a new model, make, or specific automobile, I passed the initial list and setList as props to the child component. This allowed me to change the state of the parent component within my onSubmit function in the child component. All in all, a relatively fun, learning experience for both my partner and I, who collaborated closely each step of the way, to ensure our language was ubiquitous, and our code looked similar enough to belong in the same application. A true team effort.
